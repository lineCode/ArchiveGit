// File "gammaTable.c" //// Implements a GammaTable object for altering the gamma tables of GDevices.// See "gammaTable.h" for the class definition and prototype.// This source code is adapted from the Gamma Utils Library written by MJS.//// written by Jeff Yuan 3/19/96#include <Gestalt.h>//#include <GestaltEqu.h>#include <Quickdraw.h>#include <Traps.h>#include <Video.h>#include <iostream.h>#include <fstream.h>#include <math.h>#include "gammaTable.h"#include <Palettes.h>#include "showerror.h"Boolean GammaTable::isMillionAvailable(GDHandle theGDevice) {	OSErr err;	long hasmode;		if (NGetTrapAddress(kGetDeviceListTrapNum, ToolTrap) ==			NGetTrapAddress(_Unimplemented, ToolTrap)) return(FALSE);		if (TestDeviceAttribute(theGDevice, screenDevice) && 			TestDeviceAttribute(theGDevice, noDriver)) return(FALSE);				if ((*theGDevice)->gdType == fixedType) return(FALSE);	//check the color mode	hasmode = HasDepth(theGDevice,32,gdDevType,(*theGDevice)->gdMode);	if(hasmode){		if( hasmode != (*theGDevice)->gdMode){			short yes;			yes = showError2( kMonitorErr2, 0);			if(yes)				err = SetDepth(theGDevice,32,gdDevType,hasmode);		}	}				else		showError( kMonitorErr, kCautionDlg);/*		if( (*theGDevice)->gdMode != 0x00000082 ){		hasmode = HasDepth(theGDevice,32,gdDevType,0x00000082);		if(hasmode){			short yes;			yes = showError2( kMonitorErr2, 0);			if(yes)				err = SetDepth(theGDevice,32,gdDevType,hasmode);				//err = SetDepth(theGDevice,32,gdDevType,0x00000082);		}				else			showError( kMonitorErr, kCautionDlg);	}*/	return(TRUE);}// Check to see if gamma table can be altered or supported by the device.// This is a static function - use this function to determine if a// the device gamma table can be modified before calling getDevGammaTable()// and setDevGammaTable(), or creating a GammaTable object.//// note:	clutType: uses color lookup table// 			fixedType: color table can't be changed = B/W screens, laptops?// 			directType: direct RGB colors - JCYBoolean GammaTable::isGammaAvailable(GDHandle theGDevice) {	OSErr err;	long hasmode;		if (NGetTrapAddress(kGetDeviceListTrapNum, ToolTrap) ==			NGetTrapAddress(_Unimplemented, ToolTrap)) return(FALSE);		if (TestDeviceAttribute(theGDevice, screenDevice) && 			TestDeviceAttribute(theGDevice, noDriver)) return(FALSE);				if ((*theGDevice)->gdType == fixedType) return(FALSE);			return(TRUE);}// Get the current gamma table from the device driver.// A "handle" to the system table is returned in theTable// this function is static - you can use this without // instantiating any object.OSErr GammaTable::getDevGammaTable(GDHandle theGDevice, GammaTblPtr *theTable) {	short err=0;	CntrlParam  *myCPB; 	// Set version and type to 0 ?	((long *) theTable)[0] = 0; 	// If device can't change gamma table return. 	if (!isGammaAvailable(theGDevice)) return(-1);	// Get table from driver.	if ((myCPB = (CntrlParam *) NewPtrClear(sizeof(CntrlParam))) == 0) return(MemError());	myCPB->csCode = cscGetGamma;	myCPB->ioCRefNum = (*theGDevice)->gdRefNum;	((GammaTblPtr **) myCPB->csParam)[0] = theTable;	err = PBStatus((ParmBlkPtr) myCPB, 0);	DisposePtr((Ptr) myCPB);	return(err);}// Set the current gamma table to that specified in theTable// this function is static - you can use this independent of an// instantiated object.OSErr GammaTable::setDevGammaTable(GDHandle theGDevice, GammaTblPtr *theTable) {	CntrlParam *myCPB;	short err=0;	CTabHandle cTab;	GDHandle saveGDevice;  	// If device can't change gamma table, return.	if (!isGammaAvailable(theGDevice)) return(-1);	// Tell device driver to change gamma table.	if ((myCPB = (CntrlParam *) NewPtrClear(sizeof(CntrlParam))) == 0) return(MemError());	myCPB->csCode = cscSetGamma;	myCPB->ioCRefNum = (*theGDevice)->gdRefNum;	((GammaTblPtr **) myCPB->csParam)[0] = theTable;	err = PBControl((ParmBlkPtr) myCPB, 0);  	// Update the modified device.	if (err == 0) {		saveGDevice = GetGDevice();		SetGDevice(theGDevice); 		cTab = (*(*theGDevice)->gdPMap)->pmTable;		SetEntries (0, (*cTab)->ctSize, (*cTab)->ctTable);		SetGDevice(saveGDevice);	}	DisposePtr((Ptr) myCPB);	return (err);}// GammaTable object constructors and destructor.GammaTable::GammaTable() {	originalSize = 0;	hackedSize = 0;	originalTable = nil;	hackedTable = nil;	theGDevice = nil;}GammaTable::GammaTable(GDHandle theGDevice) {	initialize(theGDevice);}GammaTable::~GammaTable() {	cleanup();}// Do initialization here.// If not using parametered constructor, call this function first.OSErr GammaTable::initialize(GDHandle theGDevice) {	originalSize = 0;	hackedSize = 0;	originalTable = nil;	hackedTable = nil;	this->theGDevice = theGDevice;	return(saveCurrentTable());}// Check to see if the gamma table object is linked to the particular device.Boolean GammaTable::isForDevice(GDHandle theGDevice) {	return(this->theGDevice == theGDevice);}// Get the handle to the GDevice.GDHandle GammaTable::getGDevice() {	return(theGDevice);}// Set the handle to the hacked table.GammaTable::setHackedTable(GammaTblHandle theHackedTableHdl) {	hackedTable = theHackedTableHdl;}		// Get the handle to the hacked table.GammaTblHandle GammaTable::getHackedTable() {	return(hackedTable);}// Set the size of the hacked table.GammaTable::setHackedSize(short size) {	hackedSize = size;}// Get the size of the hacked table.short GammaTable::getHackedSize() {	if (hackedTable == nil) hackedSize = 0;	return(hackedSize);}		// Save the original gamma table.OSErr GammaTable::saveCurrentTable() {	short err=0;	GammaTblPtr	masterGTable;	GammaTblHandle theTable;	short size;	// If device can't alter gamma tables return.	if (!isGammaAvailable(theGDevice)) return(-1);	// Hasn't been initialized yet.	if (theGDevice == nil) return(-1);	// If not able to get the current gamma table, return with error.	if (err = getDevGammaTable(theGDevice, &masterGTable)) return(err);	// Calculate the size of the current gamma table, get a handle to it	// and create a copy of the current gamma table.	size = sizeof(GammaTbl) + masterGTable->gFormulaSize +		(masterGTable->gChanCnt * masterGTable->gDataCnt * 		 masterGTable->gDataWidth / 8);		theTable = (GammaTblHandle) NewHandle(size);	if (theTable == nil) return(err = MemError());		BlockMove((Ptr) masterGTable, (Ptr) *theTable, size);	// If function is called the first time, save current table in originalTable	// so that it can always be restored regardless of subsequent changes	if (originalTable == nil) {		originalTable = theTable;		originalSize = size;	}		// Otherwise save in the hacked gamma table.	else {			// Get rid of previous saved table.		if (hackedTable != nil) DisposeHandle((Handle) hackedTable);		hackedTable = theTable;		hackedSize = size;			}	return(0);}// Restore original gamma table.OSErr GammaTable::restoreOriginalTable() {	// In case the original gamma table wasn't saved, return.	if (originalTable==nil) return(-1);		return(setDevGammaTable(theGDevice, originalTable));}// Dispose memory storage used by the object.OSErr GammaTable::cleanup() {	if (originalTable != nil) DisposeHandle((Handle) originalTable); 	if (hackedTable != nil) DisposeHandle((Handle) hackedTable);	return(0);}#define MAX(x,y) ((x)>(y)?(x):(y))// Create a gamma table with the desired maximum level, exponent, // and number of channels.  See header for explanation of these values.OSErr GammaTable::createGammaTable(RGBNumber ratio, RGBNumber targetGamma,	RGBNumber monitorGamma, short chanCount) {	short err=0;	// If device can't alter gamma tables, return.	if (!isGammaAvailable(theGDevice)) return(-1);		// Hasn't been initialized yet.	if (theGDevice == nil) return(-1);	// Invalid number of channels.	if ((chanCount!=1)&&(chanCount!=3)) return(-1);	short size;	GammaTblHandle theTable;		// Calculate the required size of the new gamma table and get a handle to it.	// Use the following fixed values.  Can we derive these values based on	// hardware/driver config?  Can't find any docs on this.  But the default	// system table uses these values.	#define FORMULA_SIZE			0						// formula size in bytes	#define DATA_COUNT			256					// number of entries per channel	#define DATA_WIDTH			8                  	// data width in bits	size = sizeof(GammaTbl)	+ FORMULA_SIZE			+ (chanCount * DATA_COUNT * DATA_WIDTH / 8);	theTable = (GammaTblHandle) NewHandle(size);	if (theTable == nil) return(err = MemError());#ifdef DEBUG	ofstream outf("createGammaTable1.out",ios::out|ios::trunc);#endif	// Fill in  table.	(*theTable)->gVersion 		= 0;	(*theTable)->gType 				= 0;	(*theTable)->gFormulaSize	= FORMULA_SIZE;	(*theTable)->gChanCnt 		= chanCount;	(*theTable)->gDataCnt 		= DATA_COUNT;	(*theTable)->gDataWidth 	= DATA_WIDTH;		unsigned char *dataPtr = (unsigned char *) (*theTable)->gFormulaData;	short i,j;		for (i=0; i<FORMULA_SIZE; i++) {		// Put formula data here.  what the hell is the formula?	}	dataPtr += (*theTable)->gFormulaSize;	RGBNumber exponent;	exponent.red 	= targetGamma.red/monitorGamma.red;	exponent.green = targetGamma.green/monitorGamma.green;	exponent.blue 	= targetGamma.blue/monitorGamma.blue;	double m;	m = MAX(ratio.red, ratio.green);	m = MAX(ratio.blue, m);	ratio.red 		/= m;	ratio.green 	/= m;	ratio.blue 	/= m;		for (i=0; i<DATA_COUNT; i++) {		dataPtr[i] = (unsigned char) (pow(((double) i)/ ((double) DATA_COUNT), exponent.red) 			* pow(ratio.red,1.0/monitorGamma.red) * DATA_COUNT);		dataPtr[i + DATA_COUNT] = (unsigned char) (pow(((double) i)/ ((double) DATA_COUNT), 			exponent.green) * pow(ratio.green,1.0/monitorGamma.green) * DATA_COUNT);			dataPtr[i + (2*DATA_COUNT)] = (unsigned char) (pow(((double) i)/((double) DATA_COUNT), 			exponent.blue) * pow(ratio.blue,1.0/monitorGamma.blue) * DATA_COUNT);#ifdef DEBUG		outf << "table[" << i << "].red = " << (short) dataPtr[i] << "\t";		outf << "table[" << i << "].green = " << (short) dataPtr[i+DATA_COUNT] << "\t";		outf << "table[" << i << "].blue = " << (short) dataPtr[i+(2*DATA_COUNT)] << "\n";#endif	}		// Done filling in table.#ifdef DEBUG	outf.close();#endif	// Set hackedTable to the new table.  If previously saved, get rid of it.	if (hackedTable != nil) DisposeHandle((Handle) hackedTable);	hackedTable = theTable;	hackedSize = size;			// Set the device gamma table to this new table.	return(setDevGammaTable(theGDevice, hackedTable));}