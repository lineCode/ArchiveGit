#include "stdafx.h"
#include <mshtmlc.h>
#include "AGPage.h"
#include "AGLayer.h"
#include "FYSPrintDoc.h"
#include "CRC32.h"
#include "HTTPClient.h"
#include "CXMLDocument.h"
#include "TrueType.h"

#define IMAGES_PATH         _T("Images")
#define FONTS_PATH			_T("Fonts")
#define XML_PATH			_T("Xml")
#define FORYOURSOUL_TXT		_T("4YourSoul.txt")
#define STREAMHDR_XML		_T("StreamHdr.xml")
#define CREATEPRINT_XML		_T("CreateAndPrint.xml")

/////////////////////////////////////////////////////////////////////////////
static bool _cdecl MyXMLCallback(int iLevel, LPCSTR pNodeName, LPCSTR pAttrName, LPCSTR pValueString, LPARAM lParam)
{
	// level 0 - probably an error
	if (!iLevel)
		return true;

	// interested only in the attributes
	if (!pAttrName)
		return true;

	CString strAttrName = pAttrName;
	strAttrName.MakeUpper();
	// interested only in Status and ErrorDescription attributes
	if ((strAttrName == "STATUS") || (strAttrName == "ERRORDESCRIPTION"))
	{
		CString strValue = pValueString;
		strValue.MakeUpper();
		// Status not OK - process the error
		if ((strAttrName == "STATUS") && (strValue != "OK"))
		{
			CString strNodeName = pNodeName;
			strNodeName.MakeUpper();

			// ignore this case since the error is with the FILE node
			if ((strNodeName == "FILES") && (strValue == "FAILED"))
				return true;

			// ignore this case since the error description is in Node XmlParseErrorDetails
			if ((strNodeName == "DATAENVELOPE") && (strValue == "MALFORMED"))
				return true;

			return false;
		}

		// Status not OK - DataEnvelope status is malformed
		if (strAttrName == "ERRORDESCRIPTION")
			return false;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
static void CALLBACK fnFileSpecs(FileStruct* pfstruct, LPARAM lParam)
{
	CFYSPrintDoc* pFYSDoc = (CFYSPrintDoc*)lParam;

	if (pfstruct)
	{
		if (pFYSDoc->FindFileSpec(pfstruct))
		{
			delete pfstruct;
			return;
		}
		pFYSDoc->AddFileSpec(pfstruct);
	}
}

/////////////////////////////////////////////////////////////////////////////
CFYSPrintDoc::CFYSPrintDoc(CAGDoc* pAGDoc)
{
	m_pAGDoc = pAGDoc;
	m_pConfig = NULL;
	m_pRes = NULL;
	m_bError = false;
}

/////////////////////////////////////////////////////////////////////////////
CFYSPrintDoc::~CFYSPrintDoc()
{
	CleanUp();
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::Initialize()
{
	if (m_strFYSTempPath.IsEmpty())
		m_strFYSTempPath = Get4YourSoulPath();

	CString strSep("\\");
	int nLen = m_strFYSTempPath.GetLength();
	if (m_strFYSTempPath[nLen-1] != strSep)
		m_strFYSTempPath += strSep;

	m_strErrorMsg = "";
	m_bError = false;

	CleanUp();

	CString strPath = m_strFYSTempPath;
	CleanDirectory(strPath);

	strPath = m_strFYSTempPath + IMAGES_PATH;
	CleanDirectory(strPath);

	strPath = m_strFYSTempPath + FONTS_PATH;
	CleanDirectory(strPath);

	strPath = m_strFYSTempPath + XML_PATH;
	CleanDirectory(strPath);
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::CleanUp()
{
	// Cleanup the files in the Temp directory - generated by us.
	char szTempPath[MAX_PATH];
	::GetTempPath(sizeof(szTempPath), szTempPath);

	for (int i=0; i<m_arFileSpecs.m_nSize; i++)
	{
		FileStruct* pfs = m_arFileSpecs[i];
		if (pfs)
		{
			if (pfs->Type == "Image")
			{
				CString strTmpFileName = szTempPath;
				strTmpFileName += pfs->FileName;
				DeleteFile(strTmpFileName);
			}
			delete pfs;
		}
	}

	HANDLE hHeap = ::GetProcessHeap();
	if (m_pConfig)
		::HeapFree(hHeap, 0, m_pConfig);

	if (m_pRes)
		::HeapFree(hHeap, 0, m_pRes);

	m_arFileSpecs.RemoveAll();
	m_pConfig = NULL;
	m_pRes = NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::CleanUpEx(LPCSTR szFile)
{
	::DeleteFile(szFile);
	CleanUp();
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::SetXmlPath(LPCTSTR pszTempPath)
{
	m_strFYSTempPath = pszTempPath;
}

/////////////////////////////////////////////////////////////////////////////
CString CFYSPrintDoc::GetXmlPath()
{
	return m_strFYSTempPath;
}

/////////////////////////////////////////////////////////////////////////////
FileStruct* CFYSPrintDoc::GetMRAImageFileSpec()
{
	int nCount = m_arFileSpecs.m_nSize;
	if (!nCount)
		return NULL;

	--nCount;
	ATLASSERT(m_arFileSpecs[nCount]->Type == "Image");

	return m_arFileSpecs[nCount];
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::WriteDIB(BYTE* pMemory, FILE* imgout)
{
	BITMAPFILEHEADER bmfhdr;
	BITMAPINFOHEADER* pInfohdr = (BITMAPINFOHEADER*)pMemory;

	bmfhdr.bfType = 0x4d42; /* 'BM' */
	bmfhdr.bfReserved1 = 0;
	bmfhdr.bfReserved2 = 0;
	bmfhdr.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);

	DWORD bpl;
	if (pInfohdr->biBitCount == 24)
	{
		bpl = pInfohdr->biWidth * 3;
	}
	else
	if (pInfohdr->biBitCount == 8)
	{
		bpl = pInfohdr->biWidth;
		bmfhdr.bfOffBits += (256 * sizeof(RGBQUAD));
	}
	else
	if (pInfohdr->biBitCount == 4)
	{
		bpl = (pInfohdr->biWidth+1)/2;
		bmfhdr.bfOffBits += (16 * sizeof(RGBQUAD));
	}
	else
	if (pInfohdr->biBitCount == 1)
	{
		bpl = (pInfohdr->biWidth+7)/8;
		bmfhdr.bfOffBits += (2 * sizeof(RGBQUAD));
	}

	bpl = (bpl + 3) & ~3;

	if (!pInfohdr->biSizeImage)
		pInfohdr->biSizeImage = bpl * pInfohdr->biHeight;

	DWORD lCount = bmfhdr.bfOffBits + pInfohdr->biSizeImage;
	bmfhdr.bfSize = lCount;

	fwrite(&bmfhdr, sizeof(BYTE), sizeof(BITMAPFILEHEADER), imgout);

	lCount -= sizeof(BITMAPFILEHEADER);
	while (lCount > 0L)
	{
		WORD wCount = ((lCount > 65500L) ? 65500 : (WORD)lCount);
		DWORD dwCount = 0;
		fwrite(pMemory, sizeof(BYTE), wCount, imgout);

		pMemory += wCount;
		lCount -= wCount;
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::DumpImageFile(CAGSymImage* pSymImage, CString& strImagePath)
{
	FileStruct* pfs = GetMRAImageFileSpec();
	if (!pfs)
	{
		SetError(String("Unknown Error writing Image file"));
		return false;
	}

	DWORD dwSrcSize = 0;
	BYTE* pMemory = pSymImage->GetImage(dwSrcSize);
	CString strImageFile = strImagePath + pfs->FileName;
	if (pSymImage->GetNativeType() != "DIB")
	{
		FILE* imgout = fopen(strImageFile, "wb");
		if (!imgout)
		{
			SetError(String("Failed to create %s", strImageFile));
			return false;
		}
		fwrite(pMemory, sizeof(BYTE), dwSrcSize, imgout);
		fclose(imgout);
	}
	else
	{
		if (!DibWrite((BITMAPINFOHEADER*)pMemory, strImageFile))
		{
			SetError(String("Failed to create %s", strImageFile));
			return false;
		}
	}

	CCRC32::FileCrc32Assembly(strImageFile, pfs->dwCRC32);
	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::DumpFontFiles(CString& strFontsPath)
{
	int Ndx = 0;
	FileStruct* pfs = NULL;
	while ((pfs = GetFontFileSpec(Ndx)))
	{
		CString strFontFileName;
		CTrueType::GetFileNameFromDisplayName(pfs->Name, strFontFileName);

		CString strDstFontFile = strFontsPath + strFontFileName;
		if (FileExists(strDstFontFile))
			continue;

		CString strSrcFontPath = CTrueType::GetPathFromFileName(strFontFileName);
		if (!CreateFontFile(strSrcFontPath, strDstFontFile))
			continue;

		pfs->FileName = StrFileName(strDstFontFile);
		pfs->dwSize = FileSize(strDstFontFile);
		CCRC32::FileCrc32Assembly(strDstFontFile, pfs->dwCRC32);
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::CreateDirAndSubDirs()
{
	// Check and create Root Dir
	int nLen = m_strFYSTempPath.GetLength();
	CString strPath = m_strFYSTempPath.Left(nLen-1);
	DWORD dwAttrs = GetFileAttributes(strPath);
	if (dwAttrs == -1)
	{
		if (!CreateDirectory(m_strFYSTempPath, NULL))
		{
			SetError(String("Failed to create directory %s\n", m_strFYSTempPath));
			return false;
		}
	}

	// Create Image sub dir
	strPath = m_strFYSTempPath + IMAGES_PATH;
	dwAttrs = GetFileAttributes(strPath);
	if (dwAttrs == -1)
	{
		if (!CreateDirectory(strPath, NULL))
		{
			SetError(String("Failed to create directory %s\n", strPath));
			return false;
		}
	}

	// Create Font sub dir
	strPath = m_strFYSTempPath + FONTS_PATH;
	dwAttrs = GetFileAttributes(strPath);
	if (dwAttrs == -1)
	{
		if (!CreateDirectory(strPath, NULL))
		{
			SetError(String("Failed to create directory %s\n", strPath));
			return false;
		}
	}

	// Create Xml sub dir
	strPath = m_strFYSTempPath + XML_PATH;
	dwAttrs = GetFileAttributes(strPath);
	if (dwAttrs == -1)
	{
		if (!CreateDirectory(strPath, NULL))
		{
			SetError(String("Failed to create directory %s\n", strPath));
			return false;
		}
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::CreateXmlDoc(CString& strOrderId, CString& strCorrId, CString& strFYSInfo, bool bUnpackFiles)
{
	if (!m_pAGDoc)
		return false;

	CWaitCursor Wait;

	Initialize();
	if (!CreateDirAndSubDirs())
		return false;

	// Documents element
	CString strDocFileName;
	{
		// strip the last "\"
		int nLen = m_strFYSTempPath.GetLength();
		CString strTempPath = m_strFYSTempPath.Left(nLen-1);

		strDocFileName = TempFileName(strTempPath, "4YS", "txt");
		strDocFileName = m_strFYSTempPath + strDocFileName;
		FILE* docout = fopen(strDocFileName, "wb");
		if (!docout)
		{
			SetError(String("Failed to open %s", strDocFileName));
			return false;
		}

		SIZE PageSize = {0,0};
		m_pAGDoc->GetPageSize(PageSize);
		double dx = DINCHES(PageSize.cx);
		double dy = DINCHES(PageSize.cy);

		fprintf(docout, "	<Documents Count='1'>\r\n");
		fprintf(docout, "		<Document CLT_CorrelationID='%s' FYS_CorrelationID='%s'>\r\n", strOrderId, strCorrId);
		fprintf(docout, "			<GreetingCard PageWidth='%0.5G' PageHeight='%0.5G' />\r\n", dx, dy);

		int nPages = m_pAGDoc->GetNumPages();
		for (int nPage = 0; nPage < nPages; nPage++)
		{
			CAGPage* pPage = m_pAGDoc->GetPage(nPage);
			if (!pPage)
				continue;

			if (!PageHasSymbols(pPage))
				continue;

			fprintf(docout, "\t\t\t<Page PageNumber='%d'>\r\n", nPage+1);

			int nLayers = pPage->GetNumLayers();
			for (int nLayer = 0; nLayer < nLayers; nLayer++)
			{
				CAGLayer* pLayer = pPage->GetLayer(nLayer);
				if (!pLayer)
					continue;

				int nSymbols = pLayer->GetNumSymbols();
				for (int nSymbol = nSymbols - 1; nSymbol >= 0; nSymbol--)
				{
					bool bRetVal = true;
					CAGSym* pSym = pLayer->GetSymbol(nSymbol);
					if (!pSym || pSym->IsHidden())
						continue;

					pSym->RegisterFileSpecsCallback(fnFileSpecs, (LPARAM)this);

					int idSym = pSym->GetID();
					bool bReposition = (idSym == IDR_AGLOGO || idSym == IDR_CARDBACK_COPYRIGHT);
					if (bReposition)
					{
						// Move these symbols up to make room for the FYS logo
						CAGMatrix Matrix = pSym->GetMatrix();
						Matrix.Translate(0, -(INCHES(0.5)));
						pSym->SetMatrix(Matrix);
					}

					pSym->WriteFYSXml(docout, 4);

					if (bReposition)
					{
						CAGMatrix Matrix = pSym->GetMatrix();
						Matrix.Translate(0, INCHES(0.5));
						pSym->SetMatrix(Matrix);
					}

					if (pSym->IsImage())
					{
						CAGSymImage* pSymImage = (CAGSymImage*)pSym;
						CString strSep("\\");
						CString strImagePath = m_strFYSTempPath + IMAGES_PATH + strSep;
						bRetVal = DumpImageFile(pSymImage, strImagePath);

						if (bRetVal)
						{
							SIZE PageSize;
							pPage->GetPageSize(PageSize);
							if (pSymImage->DoCoverDraw() && pSymImage->IsCoverAllowed())
								pSymImage->WriteXmlRects(docout, PageSize, 4);
						}
					}

					pSym->UnregisterFileSpecsCallback();
					if (!bRetVal)
						return false;
				}
			}

			fprintf(docout, "\t\t\t</Page>\r\n");
		}

		fprintf(docout, "		</Document>\r\n");
		fprintf(docout, "	</Documents>\r\n");
		fclose(docout);
	}

	CString strSep("\\");
	CString strFontsPath = m_strFYSTempPath + FONTS_PATH + strSep;
	DumpFontFiles(strFontsPath);

	// Get Configuration element
	if (!GetConfigurationElement(strFYSInfo))
	{
		CleanUpEx(strDocFileName);
		return false;
	}

	// Get Resources element
	if (!GetResourcesElement())
	{
		CleanUpEx(strDocFileName);
		return false;
	}

	// Write CreateAndPrint.xml file
	CString strXmlPath = m_strFYSTempPath + XML_PATH + strSep;
	if (!WriteCreatePrintXml(strDocFileName, strXmlPath))
	{
		CleanUpEx(strDocFileName);
		return false;
	}

	// Write StreamHdr.xml file
	if (!WriteXmlStreamHeader(strXmlPath))
	{
		CleanUp();
		return false;
	}

	// Write 4YourSoul.txt file
	if (!CreateSendFile())
	{
		CleanUp();
		return false;
	}

	if (bUnpackFiles)
		UnpackFiles();

	CleanUp();

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::SendXmlDoc(CString strURL)
{
	CComPtr<IWebBrowser2> pBrowser;
	HRESULT hr = pBrowser.CoCreateInstance(_bstr_t("InternetExplorer.Application"));
	if (hr != S_OK)
	{
		SetError("Failed to start IE!.");
		return false;
	}
	
	CString strSendFile = m_strFYSTempPath + FORYOURSOUL_TXT;
	CHTTPClient *pHttpClient = new CHTTPClient(pBrowser);
	pHttpClient->AddPostArguments("File1", strSendFile, true);
	BOOL bRetVal = pHttpClient->Request(strURL, CHTTPClient::RequestPostMethodMultiPartsFormData);
	//pHttpClient->Request("http://localhost/simpleupload/Receiver.aspx", CHTTPClient::RequestPostMethodMultiPartsFormData);

	VARIANT_BOOL bBusy = true;
	int ix = 300;
	while (bBusy)
	{
		::Sleep(100);
		pBrowser->get_Busy(&bBusy);
		if (--ix <= 0)
			break;
	}

	if (!bRetVal)
	{
		m_strErrorMsg.Format("Failed to send project to the website.");
		return false;
	}

	CComPtr<IDispatch> spDisp;

	hr = pBrowser->get_Document(&spDisp);
	if (FAILED(hr) || !spDisp)
	{
		delete pHttpClient;
		return false;
	}

	CComQIPtr<IHTMLDocument2> spDoc(spDisp);
	if (!spDoc)
	{
		m_strErrorMsg.Format("Invalid response from website after sending project successfully.");
		delete pHttpClient;
		return false;
	}
	
	CComPtr<IHTMLElement> spElem;
	hr = spDoc->get_body(&spElem);
	if (FAILED(hr) || !spDisp)
	{
		m_strErrorMsg.Format("Invalid response from website after sending project successfully.");
		delete pHttpClient;
		return false;
	}

	CString strTxt;
	CComBSTR bstr;
	spElem->get_innerHTML(&bstr);
	strTxt = bstr;

#ifdef _DEBUG
	spElem->get_innerText(&bstr);
	strTxt = bstr;
#endif

	delete pHttpClient;

	if (strTxt.Find("<FYS_DATASTREAMACKNOWLEDGMENT") < 0)
	{
		m_strErrorMsg.Format("Invalid response from website after sending project successfully.");
		return false;
	}

	strTxt = strTxt.Mid(strTxt.Find("<FYS_DATASTREAMACKNOWLEDGMENT"));

	CString strSrchPtrn("//FYS_DATASTREAMACKNOWLEDGMENT");
	CXMLDocument* pXMLDoc = new CXMLDocument;
	pXMLDoc->LoadString(strTxt);
	pXMLDoc->RegisterCallback(MyXMLCallback, (LPARAM)this);
	if (pXMLDoc->WalkTree(strSrchPtrn) != S_OK)
	{
		pXMLDoc->SetFYSError();
		m_strErrorMsg = pXMLDoc->GetErrorMsg();
		delete pXMLDoc;
		return false;
	}

	delete pXMLDoc;
	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::CreateSendFile()
{
	CString strSendFile = m_strFYSTempPath + FORYOURSOUL_TXT;
	FILE* output = fopen(strSendFile, "wb");
	if (!output)
	{
		SetError(String("Failed to open %s.", strSendFile));
		return false;
	}
	
	DWORD dwchkSum = 0;
	CString strSep("\\");
	CString strInputFile;
	CString strMiniHdr;

	// mini header for StreamHeader
	CString strPath = m_strFYSTempPath + XML_PATH + strSep;
	strInputFile = strPath + STREAMHDR_XML;
	int nSize = FileSize(strInputFile);
	CCRC32::FileCrc32Assembly(strInputFile, dwchkSum);
	strMiniHdr.Format("[%ld,%X]", nSize, dwchkSum);
	fwrite((VOID*)(LPCSTR)strMiniHdr, sizeof(char), strMiniHdr.GetLength(), output);

	// stream Header
	if (!CopyFiles(strInputFile, output))
		return false;

	// create and print xml
	strInputFile = strPath + CREATEPRINT_XML;
	if (!CopyFiles(strInputFile, output))
		return false;

	// resources
	for (int i=0; i<m_arFileSpecs.m_nSize; i++)
	{
		if (m_arFileSpecs[i]->Type == "Image")
			strInputFile = m_strFYSTempPath + IMAGES_PATH + strSep;

		if (m_arFileSpecs[i]->Type == "Font")
			strInputFile = m_strFYSTempPath + FONTS_PATH + strSep;

		strInputFile += m_arFileSpecs[i]->FileName;
		if (!CopyFiles(strInputFile, output))
			return false;
	}
	fclose(output);

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::WriteXmlStreamHeader(CString& strXmlPath)
{
	CString strStreamHdr = strXmlPath + STREAMHDR_XML;
	FILE* op = fopen(strStreamHdr, "wb");
	if (!op)
	{
		SetError(String("Failed to open %s.", strStreamHdr));
		return false;
	}
	fprintf(op, "<?xml version='1.0' encoding='UTF-8'?>\r\n");
	fprintf(op, "<!-- Confidential and Proprietory Information of 4YourSoul.com Inc..-->\r\n");
	fprintf(op, "<FYS_DataStreamHeader Version='1' ");
	fprintf(op, "xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\r\n");

	CString strCnPXmlFile = strXmlPath + CREATEPRINT_XML;
	DWORD dwSize = FileSize(strCnPXmlFile);
	DWORD dwFileSize = dwSize;
	for (int i=0; i<m_arFileSpecs.m_nSize; i++)
		dwFileSize += m_arFileSpecs[i]->dwSize;

	fprintf(op, "\t<Files Count='%s' TotalSize='%s'>\r\n", dtoa(m_arFileSpecs.m_nSize+1, 10), dtoa(dwFileSize, 10));
	DWORD dwchkSum = 1;
	DWORD dwoffSet = 0;
	CString strTmp;

	dwFileSize = dwSize;
	CCRC32::FileCrc32Assembly(strCnPXmlFile, dwchkSum);
	strTmp.Format("%X", dwchkSum);
	fprintf(op, "\t\t\t<File Type='DataEnvelope' Name='CreateAndPrint.xml' Size='%s' CRC32='%s' StartOffset='0' />\r\n",
				dtoa(dwFileSize,0), strTmp);

	dwoffSet += dwFileSize;
	for (int i=0; i<m_arFileSpecs.m_nSize; i++)
	{
		strTmp.Format("%X", m_arFileSpecs[i]->dwCRC32);
		fprintf(op, "\t\t\t<File Type='%s' Name='%s' Size='%s' CRC32='%s' StartOffset='%s' />\r\n",
					m_arFileSpecs[i]->Type, m_arFileSpecs[i]->FileName, dtoa(m_arFileSpecs[i]->dwSize,0), strTmp, dtoa(dwoffSet,0));
		dwoffSet += m_arFileSpecs[i]->dwSize;
	}

	fprintf(op, "\t</Files>\r\n");
	fprintf(op, "</FYS_DataStreamHeader>\r\n");
	fclose(op);

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::WriteCreatePrintXml(LPCSTR strDocFileName, CString& strXmlPath)
{
	CString strCnPXmlFile = strXmlPath + CREATEPRINT_XML;
	FILE* output = fopen(strCnPXmlFile, "wb");
	if (!output)
	{
		SetError(String("Failed to open %s", strCnPXmlFile));
		return false;
	}

	fprintf(output, "<?xml version='1.0' encoding='ISO-8859-1'?>\r\n");
	fprintf(output, "<!-- Confidential and Proprietory Information of 4YourSoul.com Inc..-->\r\n");
	fprintf(output, "<FYS_DataEnvelope xmlns='http://www.4yoursoul.com/Schema/2003/ClientIntegration/DataInputForPrint' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' ");
	fprintf(output, "EnvelopeVersion='2'>\r\n");

	//write the Configuration element
	HANDLE hHeap = ::GetProcessHeap();
	int nLen = ::HeapSize(hHeap, 0, m_pConfig);
	fwrite(m_pConfig, sizeof(BYTE), nLen, output);

	//write the Resources element
	nLen = ::HeapSize(hHeap, 0, m_pRes);
	fwrite(m_pRes, sizeof(BYTE), nLen, output);

	::HeapFree(hHeap, 0, m_pConfig);
	::HeapFree(hHeap, 0, m_pRes);
	m_pConfig = NULL;
	m_pRes = NULL;

	//write the Documents element
	if (!CopyFiles(strDocFileName, output))
	{
		::DeleteFile(strDocFileName);
		return false;
	}

	fprintf(output, "</FYS_DataEnvelope>\r\n");
	fclose(output);

	::DeleteFile(strDocFileName);

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::GetResourcesElement()
{
	bool bVal = AllocateHeap((DWORD)&m_pRes, "	<Resources>\r\n");
	if (!m_pRes)
	{
		SetError("Failed to allocate memory for Resources element.");
		return false;
	}

	for (int i=0; i<m_arFileSpecs.GetSize(); i++)
	{
		CString strTemp;

		if (m_arFileSpecs[i]->Type != "Font")
			continue;

		strTemp.Format("		<Font FontName='%s' FileName='%s' FileSize='%s' />\r\n",
					m_arFileSpecs[i]->Name, m_arFileSpecs[i]->FileName, dtoa(m_arFileSpecs[i]->dwSize, 0));

		bVal = AppendStringToHeap((DWORD)&m_pRes, strTemp);
	}
	bVal = AppendStringToHeap((DWORD)&m_pRes, "	</Resources>\r\n");
	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::GetConfigurationElement(CString& strFYSInfo)
{
	COleDateTime Date(COleDateTime::GetCurrentTime());
	CString strTime = Date.Format("%Y-%m-%dT%H:%M:%S");

	CString strTemp;
	strTemp.Format("	<Configuration>\r\n"
					"		<ProcessingInformation>\r\n"
					"			%s\r\n"
					"		</ProcessingInformation>\r\n"
					"		<SenderInformation FYS_ClientID='31'/>\r\n"
					"		<ThisFileInformation CreationDateTime='%s' CLT_CorrelationID='15'/>\r\n"
					"		<GlobalDocumentConfiguration UnitOfMeasure='Inches'/>\r\n"
					"	</Configuration>\r\n",
					strFYSInfo,
					strTime);

	bool bVal = AllocateHeap((DWORD)&m_pConfig, strTemp);
	if (!m_pConfig)
	{
		SetError("Failed to allocate memory for Configuration element.");
		return false;
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::PageHasSymbols(CAGPage* pPage)
{
	bool bRetVal = false;
	int nLayers = pPage->GetNumLayers();

	if (nLayers <= 0)
		return bRetVal;

	for (int nLayer = 0; nLayer < nLayers; nLayer++)
	{
		CAGLayer* pLayer = pPage->GetLayer(nLayer);
		if (!pLayer)
			continue;

		if (pLayer->GetNumSymbols())
		{
			bRetVal = true;
			break;
		}
	}

	return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::UnpackFiles()
{
	CString strTemp;
	CString strSep("\\");
	CString strFileName = m_strFYSTempPath + FORYOURSOUL_TXT;
	FILE* input = fopen(strFileName, "rb");

	HGLOBAL hMemory;
	BYTE* pMemory;

	// unpack the mini header
	hMemory = ::GlobalAlloc(GMEM_MOVEABLE, sizeof(BYTE));
	pMemory = (BYTE*)::GlobalLock(hMemory);
	char xz = ']';
	do
	{
		fread(pMemory, sizeof(BYTE), 1, input);
		strTemp += (char)*pMemory;
	}while((*(char*)pMemory) != xz);

	::GlobalUnlock(hMemory);
	::GlobalFree(hMemory);

	// unpack streamheader
	strTemp = strTemp.Mid(1, strTemp.Find(',', 0)-1);
	DWORD dwSize = atoi(strTemp);

	hMemory = ::GlobalAlloc(GMEM_MOVEABLE, dwSize);
	pMemory = (BYTE*)::GlobalLock(hMemory);

	fread(pMemory, sizeof(BYTE), dwSize, input);

	CString strPath = m_strFYSTempPath + XML_PATH + strSep;
	strTemp.Format("%sXP_%s", strPath, STREAMHDR_XML);

	FILE* output;
	output = fopen(strTemp, "wb");
	fwrite(pMemory, sizeof(BYTE), dwSize, output);
	fclose(output);

	::GlobalUnlock(hMemory);
	::GlobalFree(hMemory);

	// time to read the stream header into a xml class 
	CXMLDocument* pXMLDoc = new CXMLDocument;
	pXMLDoc->Load(strTemp, false);
	CString strCount = pXMLDoc->GetStringValue("//FYS_DataStreamHeader//Files", "Count");
	int nFileCount = atoi(strCount);
	for (int i=0, offset=0; i<nFileCount; i++)
	{
		CString strSrch = String("//FYS_DataStreamHeader//Files//File[@StartOffset = '%ld']", offset);
		CString strType = pXMLDoc->GetStringValue(strSrch, "Type");
		CString strName = pXMLDoc->GetStringValue(strSrch, "Name");
		CString strSize = pXMLDoc->GetStringValue(strSrch, "Size");
		DWORD dwSize = atoi(strSize);

		hMemory = ::GlobalAlloc(GMEM_MOVEABLE, dwSize);
		pMemory = (BYTE*)::GlobalLock(hMemory);
		fread(pMemory, sizeof(BYTE), dwSize, input);

		if (strType == "DataEnvelope")
			strPath = m_strFYSTempPath + XML_PATH + strSep;
		if (strType == "Image")
			strPath = m_strFYSTempPath + IMAGES_PATH + strSep;
		if (strType == "Font")
			strPath = m_strFYSTempPath + FONTS_PATH + strSep;

		strTemp.Format("%sXP_%s", strPath, strName);
		output = fopen(strTemp, "wb");
		fwrite(pMemory, sizeof(BYTE), dwSize, output);
		fclose(output);

		::GlobalUnlock(hMemory);
		::GlobalFree(hMemory);

		offset += dwSize;
	}

	fclose(input);
	delete pXMLDoc;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::FindFileSpec(FileStruct* pfstruct)
{
	if (!m_arFileSpecs.m_nSize)
		return false;

	if (m_arFileSpecs.Find(pfstruct) == -1)
		return false;

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::AddFileSpec(FileStruct* pfstruct)
{
	m_arFileSpecs.Add(pfstruct);
	return true;
}

/////////////////////////////////////////////////////////////////////////////
FileStruct* CFYSPrintDoc::GetFontFileSpec(int& Ndx)
{
	if (!m_arFileSpecs.m_nSize)
		return NULL;

	if (Ndx >= m_arFileSpecs.m_nSize)
		return NULL;

	for (; Ndx < m_arFileSpecs.m_nSize; Ndx++)
	{
		if (m_arFileSpecs[Ndx]->Type.CompareNoCase("Font") == 0)
			return m_arFileSpecs[Ndx++];
	}

	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CFYSPrintDoc::SetError(LPCSTR szErrorMsg)
{
	m_strErrorMsg = szErrorMsg;
	m_bError = true;
}

/////////////////////////////////////////////////////////////////////////////
CString CFYSPrintDoc::GetErrorMsg()
{
	return m_strErrorMsg;
}

//////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::CreateFontFile(CString strSrcFile, CString strDstFile)
{
	if (FileExists(strSrcFile))
	{
		HGLOBAL hMemory = ReadFileIntoMemory(strSrcFile);
		if (!hMemory)
		{
			SetError(String("Failed to open %s", strSrcFile));
			return false;
		}
			
		BYTE* pMemory = (BYTE*)::GlobalLock(hMemory);
		if (pMemory)
		{
			DWORD dwSize = ::GlobalSize(hMemory);
			WriteDataToFile(strDstFile, (LPCSTR)pMemory, dwSize);
			::GlobalUnlock(hMemory);
		}

		::GlobalFree(hMemory);
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////
bool CFYSPrintDoc::CopyFiles(LPCSTR strSrcFile, FILE* output)
{
	if (FileExists(strSrcFile))
	{
		HGLOBAL hMemory = ReadFileIntoMemory(strSrcFile);
		if (!hMemory)
		{
			SetError(String("Failed to open %s.\n", strSrcFile));
			return false;
		}
			
		BYTE* pMemory = (BYTE*)::GlobalLock(hMemory);
		if (pMemory)
		{
			DWORD dwSize = ::GlobalSize(hMemory);
			dwSize = fwrite((LPCVOID)pMemory, sizeof(BYTE), dwSize, output);
			::GlobalUnlock(hMemory);
		}

		::GlobalFree(hMemory);
	}

	return true;
}
