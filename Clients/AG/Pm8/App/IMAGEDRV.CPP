/*
//	IMAGEDRV.CPP
//
//		Copyright (C) 1993 MicroLogic Software, Inc.
//
// Image driver routines.
//
// $Header: /PM8/App/IMAGEDRV.CPP 1     3/03/99 6:06p Gbeddow $
//
// $Log: /PM8/App/IMAGEDRV.CPP $
// 
// 1     3/03/99 6:06p Gbeddow
// 
// 2     8/18/98 7:01p Jayn
// Made CreateImage work with palette images.
// 
//    Rev 1.0   14 Aug 1997 15:21:34   Fred
// Initial revision.
// 
//    Rev 1.0   14 Aug 1997 09:38:46   Fred
// Initial revision.
// 
//    Rev 1.4   11 Apr 1997 11:23:32   Jay
// Graphic cleanup; PhotoEnhancer support
// 
//    Rev 1.3   05 Dec 1996 12:30:12   Jay
// New image code for handling transparent bitmaps.
// 
//    Rev 1.2   01 Nov 1996 17:11:42   Jay
// Got rid of a lot of warnings.
// 
//    Rev 1.1   10 May 1996 16:00:08   Jay
// New compression method.
// 
//    Rev 1.0   14 Mar 1996 13:43:10   Jay
// Initial revision.
// 
//    Rev 1.1   27 Feb 1996 17:05:50   VSI
// _NEWPORTABLE 'C' code replaces .asm -- not yet working
// 
//    Rev 1.0   16 Feb 1996 12:09:54   FRED
// Initial revision.
// 
//    Rev 2.3   06 Oct 1995 11:46:16   JAY
// Fixed a reference to m_Info which was uninitialized (random display od PCD).
// 
//    Rev 2.2   18 Aug 1995 15:06:00   JAY
// Photo CD; graphic images, etc.
// 
//    Rev 2.1   09 Mar 1995 08:26:46   JAY
//  
// 
//    Rev 2.0   07 Feb 1995 15:47:54   JAY
// Initial revision.
// 
//    Rev 1.3   30 Nov 1994 16:33:46   JAY
// stdafx.h; merged database code from album
// 
//    Rev 1.2   04 Aug 1994 07:32:52   JAY
// Large model and 32-bit changes
// 
//    Rev 1.1   05 Jan 1994 08:07:10   JAY
// Restructuring, etc.
//
//   Rev 1.0   16 Dec 1993 16:25:22   JAY
// 
*/
                     
#include "stdafx.h"
#include "imagedrv.h"
#include "cimplode.h"			// Old compression method
#include "cdeflate.h"			// New compression method
#include "grafrec.h"
#include "efilerec.h"

static void near convert_bilevel(LPBYTE src_row, LPBYTE dst_row, int bytes);

/////////////////////////////////////////////////////////////////////////////
// PALETTE_INFO

PALETTE_INFO::PALETTE_INFO()
{
	m_pData = NULL;
	m_nColors = 0;
	m_fRead = FALSE;
}

void PALETTE_INFO::BuildDefaultPalette(IMAGE_INFO& Info)
{
	COLOR_COMPONENT far *p = (COLOR_COMPONENT far *)m_pData;
	SHORT i;

/*
// We need to build a palette.
// The assumption here is that a planar image is color whilst
// a chunky (multiple bpp) image is grayscale.
// It just seems to be that way (JN).
// (Planar seems to correspond to screen layouts like CGA and EGA.
// Chunky is usually generated by a gray-scale scanner.)
*/

	if (Info.bpp != 1)
	{
		SHORT step = 256/m_nColors;

		// Build a gray palette.

		for (i = 0; i < 256; i += step)
		{
			*p++ = (UCHAR)i;
			*p++ = (UCHAR)i;
			*p++ = (UCHAR)i;
		}
	}
	else
	{
		switch (m_nColors)
		{
			case 2:
			{
				// Build a 2-color RGB palette.
				*p++ = 0;
				*p++ = 0;
				*p++ = 0;

				*p++ = 255;
				*p++ = 255;
				*p++ = 255;

				break;
			}
			case 4:
			{
				// Build a 4-color RGB palette.
				for (i = 0; i < 4; i++)
				{
					*p++ = 255;
					*p++ = (UCHAR)((i & 2) ? 255 : 0);
					*p++ = (UCHAR)((i & 1) ? 255 : 0);
				}
				break;
			}
			case 8:
			case 16:
			{
				// Build an 8/16 color RGB palette.
				for (i = 0; i < m_nColors; i++)
				{
					*p++ = (UCHAR)((i & 4) ? 255 : 0);
					*p++ = (UCHAR)((i & 2) ? 255 : 0);
					*p++ = (UCHAR)((i & 1) ? 255 : 0);
				}
				break;
			}
			default:
			{
				break;
			}
		}
	}

	// We have something.
	m_fRead = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// ImageDriver

/*
// Constructor for an image driver.
*/

ImageDriver::ImageDriver()
{
	convert = NULL;
	m_pImageRow = NULL;
	m_pMaskRow = NULL;
}

/*
// Destructor for an image driver.
*/

ImageDriver::~ImageDriver()
{
	close();
}

/*
// Free the source row if we allocated one.
*/

void ImageDriver::FreeRows(void)
{
	delete [] m_pImageRow;
   m_pImageRow = NULL;
	delete [] m_pMaskRow;
   m_pMaskRow = NULL;
}

/*
// Get info about the image.
*/

ERRORCODE ImageDriver::info(IMAGE_INFO_PTR info)
{
	ERRORCODE error;

	our_info = *info;

	if ((error = image_info(&our_info)) == ERRORCODE_None)
	{
	/* Compute how many colors we have for palette allocation. */
		SHORT image_bits = our_info.planes * our_info.bpp;

		our_info.bytes_per_pixel = 1;

		switch (image_bits)
		{
			case 1:
			{
				our_info.colors = 2;
				break;
			}
			case 2:
			{
				our_info.colors = 4;
				break;
			}
			case 3:
			{
				our_info.colors = 8;
				break;
			}
			case 4:
			{
				our_info.colors = 16;
				break;
			}
			case 8:
			{
				our_info.colors = 256;
				break;
			}
			case 24:
			{
				our_info.colors = -1;
				our_info.bytes_per_pixel = 3;
				break;
			}
			default:
			{
				return ERRORCODE_IllegalType;
			}
		}

		// Compute the number of bytes we need in a row.
		// Note that image data is always 8 bpp or 24 bpp.
		// (This calculation makes sure we have a full byte padded row for
		// sources with bpp < 8. This value may be more than necessary, but
		// it will be sufficient.)

      if (our_info.colors > 0 && our_info.colors < 256)
      {
         our_info.row_bytes = ((our_info.width+7) & ~7) * our_info.bytes_per_pixel;
      }
      else
      {
         our_info.row_bytes = our_info.width * our_info.bytes_per_pixel;
      }

		// Compute the number of bytes in a mask row.
		// Note that the mask is always 8 bpp.

		if (our_info.m_fHasMask)
		{
			our_info.m_nMaskRowBytes = (our_info.width+7) & ~7;
		}
		*info = our_info;
	}

	return error;
}

/*
// Read lines.
// This will handle conversion if necessary.
*/

ERRORCODE ImageDriver::read(int nLine, LPBYTE pImage, int nCount, LPBYTE pMask)
{
	if (m_pImageRow == NULL && m_pMaskRow == NULL)
	{
		return read_lines(nLine, pImage, nCount, pMask);
	}
	else
	{
		ERRORCODE error = ERRORCODE_None;

		for (int i = 0; i < nCount; i++, nLine++)
		{
			// Read...
			if ((error = read_lines(nLine,
											(m_pImageRow == NULL) ? pImage : m_pImageRow,
											1,
											(m_pMaskRow == NULL) ? pMask : m_pMaskRow)) != ERRORCODE_None)
			{
				break;
			}

			// ... and convert.
			if (m_pImageRow != NULL)
			{
				convert(m_pImageRow, pImage, source_row_bytes);
			}
			if (m_pMaskRow != NULL)
			{
				// Bilevel to 8-bit.
				convert_bilevel(m_pMaskRow, pMask, m_nMaskRowSize);
			}
			pImage += our_info.row_bytes;
			pMask += our_info.m_nMaskRowBytes;
		}
		return error;
	}
}

/*
// Close the driver.
*/

VOID ImageDriver::close(VOID)
{
	close_image();
	FreeRows();
}



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a bilevel row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_bilevel(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	BYTE	c;
	int	i;

	ASSERT(bytes > 0);

	do 
	{
		c = *src_row++;
		for (i = 1;  i <= 8;  ++i)
		{
			*dst_row++ = ((c & 0x80) ? 1 : 0);
			c <<= 1;
		}

	} while (--bytes);

	return;

#else

#ifdef _WIN32
	_asm
	{
		mov	esi, src_row		; source to ds:si
		mov	edi, dst_row		; dest to es:di
		mov	ecx, bytes		; that many bytes to do

	ptc0:

		lodsb
		mov	ah, al

	; First pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Second pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Third pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Fourth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Fifth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Sixth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Seventh pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Eighth pixel.

		xor	al, al
		rol	ax, 1
		stosb

		loop	ptc0
	}
#else
	_asm
	{
		push	ds

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	cx, bytes		; that many bytes to do

	ptc0:

		lodsb
		mov	ah, al

	; First pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Second pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Third pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Fourth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Fifth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Sixth pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Seventh pixel.

		xor	al, al
		rol	ax, 1
		stosb

	; Eighth pixel.

		xor	al, al
		rol	ax, 1
		stosb

		loop	ptc0

		pop	ds
	}

#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convet_bilevel



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a 2 planar row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_planar2(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	LPBYTE	src_row2;
	BYTE	c1, c2;
	int	i;

	ASSERT(bytes > 0);

	src_row2 = src_row + bytes;

	do 
	{
		c1 = *src_row++;
		c2 = *src_row2++;

		for (i = 1;  i <= 8;  ++i)
		{
			*dst_row++ = ((c2 & 0x80) ? 2 : 0) |
				     ((c1 & 0x80) ? 1 : 0);
			c1 <<= 1;
			c2 <<= 1;
		}

	} while (--bytes);

	return;

#else

#ifdef _WIN32
	_asm
	{
		push	ebp

		mov	esi, src_row	; source to esi
		mov	edi, dst_row	; dest to edi
		mov	ebp, bytes	; NOTE: can't access params 
					;   anymore now!
		mov	ebx, ebp						; that many bytes to do

	ptc0:

		mov	dh, [esi]	; plane 1
		mov	dl, [esi+ebx]	; plane 2	
		inc	esi							; next source byte

	; First pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Third pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	ebp
		jnz	ptc0
;		jmp	ptc0		; Damn! Short jump out of range.

;	ptc1:

		pop	ebp
	}
#else
	_asm
	{
		push	ds
		push	bp

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	bp, bytes		; NOTE: can't access 
						;   params anymore now!

		mov	bx, bp			; that many bytes to do

	ptc0:

		mov	dh, [si]		; plane 1
		mov	dl, [si+bx]		; plane 2
		inc	si							; next source byte

	; First pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Third pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	bp
		jnz	ptc0
;		jmp	ptc0		; Damn! Short jump out of range.

;	ptc1:

		pop	bp
		pop	ds
	}

#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convert_planar2



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a 3 planar row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_planar3(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	LPBYTE	src_row2, src_row3;
	BYTE	c1, c2, c3;
	int	i;

	ASSERT(bytes > 0);

	src_row2 = src_row + bytes;
	src_row3 = src_row + 2*bytes;

	do 
	{
		c1 = *src_row++;
		c2 = *src_row2++;
		c3 = *src_row3++;

		for (i = 1;  i <= 8;  ++i)
		{
			*dst_row++ = ((c3 & 0x80) ? 4 : 0) |
				     ((c2 & 0x80) ? 2 : 0) |
				     ((c1 & 0x80) ? 1 : 0);
			c1 <<= 1;
			c2 <<= 1;
			c3 <<= 1;
		}

	} while (--bytes);

	return;

#else

#ifdef _WIN32
	_asm
	{
		push	ebp

		mov	esi, src_row		; source to esi
		mov	edi, dst_row		; dest to edi
		mov	ebp, bytes		; NOTE: can't access 
						;   params anymore now!
		mov	ebx, ebp		; that many bytes to do

	ptc0:

		mov	dh, [esi]		; plane 1
		add	esi, ebx
		mov	dl, [esi]		; plane 2
		mov	cl, [esi+ebx]		; plane 3
		sub	esi, ebx
		inc	esi			; next source byte

	; First pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Third pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	ebp
		jz	ptc1
		jmp	ptc0		; Damn! Short jump out of range.

	ptc1:

		pop	ebp
	}
#else
	_asm
	{
		push	ds
		push	bp

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	bp, bytes					; NOTE: can't access params anymore now!

		mov	bx, bp						; that many bytes to do

	ptc0:

		mov	dh, [si]					; plane 1
		add	si, bx
		mov	dl, [si]					; plane 2
		mov	cl, [si+bx]				; plane 3
		sub	si, bx
		inc	si							; next source byte

	; First pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Third pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	bp
		jz	ptc1
		jmp	ptc0						; Damn! Short jump out of range.

	ptc1:

		pop	bp
		pop	ds
	}

#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convert_planar3



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a 4 planar row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_planar4(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	LPBYTE	src_row2, src_row3, src_row4;
	BYTE	c1, c2, c3, c4;
	int	i;

	ASSERT(bytes > 0);

	src_row2 = src_row + bytes;
	src_row3 = src_row + 2*bytes;
	src_row4 = src_row + 3*bytes;

	do 
	{
		c1 = *src_row++;
		c2 = *src_row2++;
		c3 = *src_row3++;
		c4 = *src_row4++;

		for (i = 1;  i <= 8;  ++i)
		{
			*dst_row++ = ((c4 & 0x80) ? 8 : 0) |
				     ((c3 & 0x80) ? 4 : 0) |
				     ((c2 & 0x80) ? 2 : 0) |
				     ((c1 & 0x80) ? 1 : 0);
			c1 <<= 1;
			c2 <<= 1;
			c3 <<= 1;
			c4 <<= 1;
		}

	} while (--bytes);

	return;

#else

#ifdef _WIN32
	_asm
	{
		push	ebp

		mov	esi, src_row		; source to esi
		mov	edi, dst_row		; dest to edi
		mov	ebp, bytes		; NOTE: can't access 
						;   params anymore now!
		mov	ebx, ebp		; that many bytes to do

	ptc0:

		mov	dh, [esi]		; Red
		mov	dl, [esi+ebx]		; Green
		add	esi, ebx
		add	esi, ebx
		mov	ch, [esi]		; Blue
		mov	cl, [esi+ebx]		; Intensity
		sub	esi, ebx
		sub	esi, ebx
		inc	esi							; next source byte

	; First pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Third pixel.

		xor	ax, ax
		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	ebp
		jz	ptc1
		jmp	ptc0		; Damn! Short jump out of range.

	ptc1:

		pop	ebp
	}
#else
	_asm
	{
		push	ds
		push	bp

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	bp, bytes					; NOTE: can't access params anymore now!

		mov	bx, bp						; that many bytes to do

	ptc0:

		mov	dh, [si]					; Red
		mov	dl, [si+bx]				; Green
		add	si, bx
		add	si, bx
		mov	ch, [si]					; Blue
		mov	cl, [si+bx]				; Intensity
		sub	si, bx
		sub	si, bx
		inc	si							; next source byte


	; First pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Second pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Third pixel.

		xor	ax, ax
		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Fourth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

	; Fifth pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Sixth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1
		stosw

	; Seventh pixel.

		xor	ax, ax

		shl	cl, 1
		rcl	al, 1
		shl	ch, 1
		rcl	al, 1
		shl	dl, 1
		rcl	al, 1
		shl	dh, 1
		rcl	al, 1

	; Eighth pixel.

		shl	cl, 1
		rcl	ah, 1
		shl	ch, 1
		rcl	ah, 1
		shl	dl, 1
		rcl	ah, 1
		shl	dh, 1
		rcl	ah, 1

		stosw

		dec	bp
		jz		ptc1
		jmp	ptc0						; Damn! Short jump out of range.

	ptc1:

		pop	bp
		pop	ds
	}
#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convert_planar4



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a 2 chunky row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_chunky2(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	BYTE	c;
	int	i;

	ASSERT(bytes > 0);

	do 
	{
		c = *src_row++;

		for (i = 1;  i <= 4;  ++i)
		{
			*dst_row++ = (c >> 6);
			c <<= 2;
		}

	} while (--bytes);

	return;
#else

#ifdef _WIN32
	_asm
	{
		mov	esi, src_row	; source to esi
		mov	edi, dst_row	; dest to edi
		mov	ecx, bytes

	ptc0:

		lodsb			; grab the byte (contains four 
					;   2-bit pixels)
		mov	dl, al		; save in dl for third and fourth

		shr	al, 4		; first and second pixels down

		mov	ah, al		; second pixel to ah
		shr	al, 1		; shift first pixel down in al
		shr	al, 1		; shift first pixel down in al
		and	ax, 00303h	; mask off desired pixels
		stosw			; store the two pixels

		mov	al, dl		; restore third and fourth pixels

		mov	ah, al		; fourth pixel to ah
		shr	al, 1		; shift third pixel down in al
		shr	al, 1		; shift third pixel down in al
		and	ax, 00303h	; mask off desired pixels
		stosw			; store the two pixels

		loop	ptc0		; if there is more, do them
	}
#else
	_asm
	{
		push	ds

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	bx, bytes

		mov	cl, 4						; a good shift factor

	ptc0:

		lodsb								; grab the byte (contains four 2-bit pixels)

		mov	dl, al					; save in dl for third and fourth

		shr	al, cl					; first and second pixels down

		mov	ah, al					; second pixel to ah
		shr	al, 1						; shift first pixel down in al
		shr	al, 1						; shift first pixel down in al
		and	ax, 00303h				; mask off desired pixels
		stosw								; store the two pixels

		mov	al, dl					; restore third and fourth pixels

		mov	ah, al					; fourth pixel to ah
		shr	al, 1						; shift third pixel down in al
		shr	al, 1						; shift third pixel down in al
		and	ax, 00303h				; mask off desired pixels
		stosw								; store the two pixels

		dec	bx							; decrement our count
		jnz	ptc0						; if there is more, do them

		pop	ds
	}

#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convert_chunky2



/*
The asm code below was converted to C code by Roger House 96/02/22.

Note:  The way the asm code is written, the input parameter bytes MUST
be positive, never zero or less.  Hence the assert is used in the C code.

Convert a 4 chunky row to an 8-bit chunky row.
*/

PRIVATE VOID near
convert_chunky4(LPBYTE src_row, LPBYTE dst_row, int bytes)
{
#ifdef _NEWPORTABLE

	BYTE	c;
	int	i;

	ASSERT(bytes > 0);

	do 
	{
		c = *src_row++;

		for (i = 1;  i <= 2;  ++i)
		{
			*dst_row++ = (c >> 4);
			c <<= 4;
		}

	} while (--bytes);

	return;
#else

#ifdef _WIN32
	_asm
	{
		mov	esi, src_row	; source to esi
		mov	edi, dst_row	; dest to edi
		mov	ecx, bytes

	ptc0:

		lodsb			; grab the byte (contains two 
					;   4-bit pixels)
		mov	ah, al		; second pixel to ah
		and	ah, 00fh	; mask off first pixel from ah
		shr	al, 4		; shift first pixel down in al
		stosw			; store the two pixels

		loop	ptc0		; if there is more, do them
	}
#else
	_asm
	{
		push	ds

		lds	si, dword ptr src_row	; source to ds:si
		les	di, dword ptr dst_row	; dest to es:di
		mov	bx, bytes

		mov	cl, 4

	ptc0:

		lodsb								; grab the byte (contains two 4-bit pixels)
		mov	ah, al					; second pixel to ah
		and	ah, 00fh					; mask off first pixel from ah
		shr	al, cl					; shift first pixel down in al
		stosw								; store the two pixels

		dec	bx							; decrement our count
		jnz	ptc0						; if there is more, do them

		pop	ds
	}

#endif	// _WIN32

#endif	// _NEWPORTABLE

} // end convert_chunky4


/*
// Open the image.
// This may allocate memory if data conversion will be necessary.
*/

ERRORCODE ImageDriver::open(PALETTE_INFO_PTR palette)
{
	// Compute the size of a row ignoring planes.
	source_row_bytes = (our_info.width*our_info.bpp + 7)/8;

	// Now compute the full memory requirements for a row.
	source_row_size = source_row_bytes * our_info.planes;

	// Compute the convert function if one is needed.

	if (our_info.bpp != 8)
	{
	/*
 	// We need to convert.
	// All conversion cases go to 8 bpp.
	// Cases:
	//			1-bit planar (bilevel)
	//			2-bit chunky
	//			2-bit planar
	//			3-bit planar
	//			4-bit chunky
	//			4-bit planar
 	*/

		switch (our_info.bpp)
		{
			case 1:
			{
				switch (our_info.planes)
				{
					case 1:
					{
						convert = convert_bilevel;
						break;
					}
					case 2:
					{
						convert = convert_planar2;
						break;
					}
					case 3:
					{
						convert = convert_planar3;
						break;
					}
					case 4:
					{
						convert = convert_planar4;
						break;
					}
					default:
					{
					/* Should not happen! */
						return ERRORCODE_IllegalType;
					}
				}
				break;
			}
			case 2:
			{
				convert = convert_chunky2;
				break;
			}
			case 4:
			{
				convert = convert_chunky4;
				break;
			}
			default:
			{
			/* Should not happen! */
				return ERRORCODE_IllegalType;
			}
		}

		// We need to allocate the temporary source row.
		ASSERT(m_pImageRow == NULL);
		TRY
		{
			m_pImageRow = new BYTE[source_row_size+4];
		}
		END_TRY
		if (m_pImageRow == NULL)
		{
			return ERRORCODE_Memory;
		}
	}

	if (our_info.m_fHasMask)
	{
		// Compute the size of a source mask row.
		m_nMaskRowSize = (our_info.width*our_info.m_nMaskBpp + 7)/8;

		// If the mask is bilevel, then we need to read it in as 1-bit
		// (assumed) and convert it to 8-bit.
		if (our_info.m_nMaskBpp != 8)
		{
			// We need to convert. Allocate the 1-bit row to use for reading.
			ASSERT(our_info.m_nMaskBpp == 1);
			ASSERT(m_pMaskRow == NULL);
			TRY
			{
				m_pMaskRow = new BYTE[m_nMaskRowSize];
			}
			END_TRY
			if (m_pMaskRow == NULL)
			{
				return ERRORCODE_Memory;
			}
		}
	}

	return open_image(palette);
}

/////////////////////////////////////////////////////////////////////////////
// GraphicImageDriver

GraphicImageDriver::GraphicImageDriver(GraphicRecord* pGraphic)
{
	m_pGraphic = pGraphic;

	m_pHeader = NULL;
	m_hStrip = NULL;
	m_pStrip = NULL;
}

GraphicImageDriver::~GraphicImageDriver()
{
	delete [] (LPBYTE)m_pHeader;
	if (m_hStrip != NULL)
	{
		if (m_pStrip != NULL)
		{
			::GlobalUnlock(m_hStrip);
		}
		::GlobalFree(m_hStrip);
	}
}

BOOL GraphicImageDriver::Init(void)
{
/*
// Embedded prep.
// Use an embedded file if one is available.
*/

	if (m_pGraphic->record.image != 0)
	{
		DatabasePtr pDatabase = m_pGraphic->GetDatabase();

		EmbeddedFileCPtr efile;

		if ((efile = (EmbeddedFileCPtr)pDatabase->get_record(m_pGraphic->record.image, NULL, RECORD_TYPE_EmbeddedFile, TRUE)) != NULL)
		{
			if (efile->prep_file(&m_File, TRUE) == ERRORCODE_None)
			{
			/*
			// Now we want to read the header. If this fails, we bail.
			*/
				if (ReadHeader() == ERRORCODE_None)
				{
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

ERRORCODE GraphicImageDriver::image_info(IMAGE_INFO_PTR info)
{
	*info = m_pHeader->m_Info;
	return ERRORCODE_None;
}

ERRORCODE GraphicImageDriver::open_image(PALETTE_INFO_PTR palette)
{
	ERRORCODE error = ERRORCODE_None;

	// Handle the palette if necessary.
	if (palette != NULL)
	{
		if (m_pHeader->m_Info.image_type != IMAGE_FULL_COLOR)
		{
			// We want to read the palette.
			ERRORCODE error;
			if ((error = m_File.read(palette->m_pData, 256*sizeof(RGBTRIPLE))) == ERRORCODE_None)
			{
				palette->m_fRead = TRUE;
			}
		}
	}
	return error;
}

ERRORCODE GraphicImageDriver::read_lines(int nLine, LPBYTE pImage, int nCount, LPBYTE pMask)
{
	ASSERT(pMask == NULL);

	int nHeight = m_pHeader->m_Info.height;
	if (nLine < 0 || nLine >= nHeight)
	{
		return ERRORCODE_BadParameter;
	}

	if (m_pStrip == NULL)
	{
	/* Try to allocate the band memory. */

		if ((m_hStrip = ::GlobalAlloc(GMEM_MOVEABLE, m_pHeader->m_dwBandSize)) != NULL)
		{
			if ((m_pStrip = (LPBYTE)::GlobalLock(m_hStrip)) == NULL)
			{
				::GlobalFree(m_hStrip);
				return ERRORCODE_Memory;
			}
			m_nStripTop = -1;
		}
	}

	ERRORCODE error = ERRORCODE_None;

	while (nCount != 0)
	{
		if (nLine >= nHeight)
		{
			return ERRORCODE_IntError;
		}

		if (m_nStripTop == -1
				|| nLine < m_nStripTop
				|| nLine >= m_nStripTop + m_nStripLines)
		{
		/* We need to read the next chunk. */
			WORD wStrip = (WORD)nLine/(WORD)m_pHeader->m_dwBandHeight;
			if ((error = ReadStrip(wStrip)) != ERRORCODE_None)
			{
				break;
			}
		}

	/* Now we copy lines out. */

		LPBYTE pSource = m_pStrip + (nLine - m_nStripTop)*m_wRowBytes;
		int nLines = nCount;
		int nMaxLine = m_nStripTop + m_nStripLines;
		if (nLine + nLines >= nMaxLine)
		{
			nLines = nMaxLine - nLine;
		}

		WORD wSize = (WORD)nLines*m_wRowBytes;
		memcpy(pImage, pSource, wSize);

		nCount -= nLines;
		pImage += wSize;
		nLine += nLines;
	}

	return error;
}

ERRORCODE GraphicImageDriver::ReadHeader(void)
{
	ERRORCODE error;
	if ((error = m_File.seek(0L, ST_DEV_SEEK_SET)) == ERRORCODE_None)
	{
	/*
	// Read the first DWORD in the header. This tells us the number of bands,
	// which tells us the size of the whole header.
	*/
		DWORD dwBandCount;

		if ((error = m_File.read(&dwBandCount, sizeof(dwBandCount))) == ERRORCODE_None)
		{
		// Pick an arbitrary validation number.
			if (dwBandCount == 0 || dwBandCount > 256)
			{
				/* We don't like the way this looks. */
				error = ERRORCODE_InvalidRecord;
			}
			else
			{
			/*
			// Allocate the header.
			*/

				UINT uHeaderSize = sizeof(CGraphicImageHeader)+(WORD)dwBandCount*sizeof(DWORD);
				m_pHeader = (CGraphicImageHeader*)(new BYTE[uHeaderSize]);

			/*
			// Fill out the header.
			*/

				m_pHeader->m_dwBandCount = dwBandCount;
				if ((error = m_File.read(&m_pHeader->m_dwBandHeight, uHeaderSize - sizeof(dwBandCount))) == ERRORCODE_None)
				{
					// Fill out some important variables.
					m_wRowBytes = m_pHeader->m_Info.row_bytes;
										
				}
				m_Info = m_pHeader->m_Info;
			}
		}
	}
	return error;
}

ERRORCODE GraphicImageDriver::ReadStrip(UINT uStrip)
{
	int nHeight = m_pHeader->m_Info.height;
	m_nStripLines = (int)m_pHeader->m_dwBandHeight;
	m_nStripTop = uStrip*m_nStripLines;

	if (m_nStripTop + m_nStripLines >= nHeight)
	{
		m_nStripLines = nHeight - m_nStripTop;
	}

	DWORD dwOffset = m_pHeader->m_dwOffset[uStrip];
	DWORD dwCompressedSize = m_pHeader->m_dwOffset[uStrip+1] - dwOffset;

	ERRORCODE error = ERRORCODE_Memory;

	HGLOBAL hBand;
	if ((hBand = ::GlobalAlloc(GMEM_MOVEABLE, dwCompressedSize)) != NULL)
	{
		LPBYTE pBand;
		if ((pBand = (LPBYTE)::GlobalLock(hBand)) != NULL)
		{
			if ((error = m_File.seek(dwOffset, ST_DEV_SEEK_SET)) == ERRORCODE_None
				 && (error = m_File.huge_read(pBand, dwCompressedSize)) == ERRORCODE_None)
			{
			/* Do the decompress. */
				if (m_pHeader->m_wFlags & CGraphicImageHeader::FLAG_DeflateCompression)
				{
					CDeflate def;

					LPBYTE pData = NULL;
					DWORD dwSize = 0;
					def.Decompress(pBand, dwCompressedSize, &pData, &dwSize);
					if (pData != NULL)
					{
						memcpy(m_pStrip, pData, (size_t)dwSize);
						CDeflate::FreeData(pData);
					}
				}
				else
				{
					CImplode imp;
					imp.Decompress(pBand, dwCompressedSize, m_pStrip);
				}
			}
			::GlobalUnlock(hBand);
		}
		::GlobalFree(hBand);
	}
	return error;
}
